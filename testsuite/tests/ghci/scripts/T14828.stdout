foldl :: (t @@ a, Foldable t) => (b -> a -> b) -> b -> t a -> b
foldl = (_t1::t1)
fmap :: (f @@ b, f @@ a, Functor f) => (a -> b) -> f a -> f b
fmap = (_t2::t1)
return :: (m @@ a, Monad m) => a -> m a
return = (_t3::t1)
pure :: (f @@ a, Applicative f) => a -> f a
pure = (_t4::t1)
mempty = (_t5::t1)
mappend = (_t6::t1)
foldl' = (_t7::t1)
f = (_t8::t1)
